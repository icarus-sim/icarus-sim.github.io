<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>icarus.scenarios package &mdash; Icarus 0.6.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Icarus 0.6.0 documentation" href="../index.html" />
    <link rel="up" title="icarus package" href="icarus.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Icarus 0.6.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="icarus.html" accesskey="U">icarus package</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">icarus.scenarios package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-icarus.scenarios.algorithms">icarus.scenarios.algorithms module</a></li>
<li><a class="reference internal" href="#module-icarus.scenarios.cacheplacement">icarus.scenarios.cacheplacement module</a></li>
<li><a class="reference internal" href="#module-icarus.scenarios.contentplacement">icarus.scenarios.contentplacement module</a></li>
<li><a class="reference internal" href="#module-icarus.scenarios.topology">icarus.scenarios.topology module</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#module-icarus.scenarios.workload">icarus.scenarios.workload module</a></li>
<li><a class="reference internal" href="#module-icarus.scenarios">Module contents</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="icarus-scenarios-package">
<h1>icarus.scenarios package<a class="headerlink" href="#icarus-scenarios-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-icarus.scenarios.algorithms">
<span id="icarus-scenarios-algorithms-module"></span><h2>icarus.scenarios.algorithms module<a class="headerlink" href="#module-icarus.scenarios.algorithms" title="Permalink to this headline">¶</a></h2>
<p>Various algorithms used for optimal cache placement.</p>
<dl class="function">
<dt id="icarus.scenarios.algorithms.pam">
<code class="descname">pam</code><span class="sig-paren">(</span><em>distances</em>, <em>k</em>, <em>n_iter=10</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/algorithms.html#pam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.algorithms.pam" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute k-medoids using the PAM algorithm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>distances</strong> : 2-d NumPy array</p>
<blockquote>
<div><p>Array of distances between points</p>
</div></blockquote>
<p><strong>k</strong> : int</p>
<blockquote>
<div><p>Number of clusters</p>
</div></blockquote>
<p><strong>n_iter</strong> : int</p>
<blockquote class="last">
<div><p>Number of iterations to repeat. Each repetition is executed using a
different initial random assignment. Repetiting the experiment allow
to reach different local optima, possibly achieving a best solution.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Implementation based on:
<a class="reference external" href="https://github.com/salspaugh/machine_learning/blob/master/clustering/kmedoids.py">https://github.com/salspaugh/machine_learning/blob/master/clustering/kmedoids.py</a></p>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.algorithms.extract_cluster_level_topology">
<code class="descname">extract_cluster_level_topology</code><span class="sig-paren">(</span><em>topology</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/algorithms.html#extract_cluster_level_topology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.algorithms.extract_cluster_level_topology" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a cluster-level topology.</p>
<p>Each node in the topology must be have the &#8216;cluster&#8217; attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The router-level topology</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote class="last">
<div><p>The cluster-level topology</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>Each router must have a cache deployed</li>
<li>All sources and receiver must have one single attachment point with a
cache</li>
<li>Each node must be labelled with cluster</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.algorithms.deploy_clusters">
<code class="descname">deploy_clusters</code><span class="sig-paren">(</span><em>topology</em>, <em>clusters</em>, <em>assign_src_rcv=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/algorithms.html#deploy_clusters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.algorithms.deploy_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate topology with cluster informations</p>
<p>This function checks that all ICR candidate nodes are assigned exactly
to one cluster.</p>
<p>If assign_src_rcv is True, then it also labels source and receiver nodes
to the closest cluster.</p>
<dl class="docutils">
<dt>This function assumes that:</dt>
<dd><ul class="first last simple">
<li>each node of the topology is either an icr_candidate, a source or a receiver</li>
<li>each source and receiver must have degree equal to 1</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology onto which deploy clusters</p>
</div></blockquote>
<p><strong>clusters</strong> : list of sets</p>
<blockquote>
<div><p>Router-cluster assignment. Each element of a list is a set of node
identifiers. Nodes in the same set belong to the same cluster.
The length of the list therefore corresponds to the number of clusters.</p>
</div></blockquote>
<p><strong>assign_src_rcv</strong> : bool, optional</p>
<blockquote class="last">
<div><p>If <em>True</em>, the function labels source and receiver nodes with the
cluster label of the router they are attached to.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.algorithms.compute_clusters">
<code class="descname">compute_clusters</code><span class="sig-paren">(</span><em>topology</em>, <em>k</em>, <em>distance='delay'</em>, <em>nbunch=None</em>, <em>n_iter=10</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/algorithms.html#compute_clusters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.algorithms.compute_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster nodes of a topologies as to minimize the intra-cluster latency.</p>
<p>This function assumes that every link is labelled with latencies and
performs clustering using the k-medoids method with the PAM algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology</p>
</div></blockquote>
<p><strong>k</strong> : int</p>
<blockquote>
<div><p>The number of clusters</p>
</div></blockquote>
<p><strong>distance</strong> : str, optional</p>
<blockquote>
<div><p>The link metric used to represent distance between nodes.
If None, hop count is used instead</p>
</div></blockquote>
<p><strong>n_iter</strong> : int, optional</p>
<blockquote class="last">
<div><p>The number of iterations</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.algorithms.compute_p_median">
<code class="descname">compute_p_median</code><span class="sig-paren">(</span><em>distances</em>, <em>p</em>, <em>n_iter=20</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/algorithms.html#compute_p_median"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.algorithms.compute_p_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute p-median solution using the Adjusted Vertex Substitution (AVS)
algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>distances</strong> : dict of dicts</p>
<blockquote>
<div><p>Distance between nodes</p>
</div></blockquote>
<p><strong>p</strong> : int</p>
<blockquote class="last">
<div><p>Number of facilities</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-icarus.scenarios.cacheplacement">
<span id="icarus-scenarios-cacheplacement-module"></span><h2>icarus.scenarios.cacheplacement module<a class="headerlink" href="#module-icarus.scenarios.cacheplacement" title="Permalink to this headline">¶</a></h2>
<p>Cache placement strategies</p>
<p>This module provides algorithms for performing cache placement, i.e., given
a cumulative cache size and a topology where each possible node candidate is
labelled, these functions deploy caching space to the nodes of the topology.</p>
<dl class="function">
<dt id="icarus.scenarios.cacheplacement.uniform_cache_placement">
<code class="descname">uniform_cache_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>cache_budget</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/cacheplacement.html#uniform_cache_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.cacheplacement.uniform_cache_placement" title="Permalink to this definition">¶</a></dt>
<dd><p>Places cache budget uniformly across cache nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>cache_budget</strong> : int</p>
<blockquote class="last">
<div><p>The cumulative cache budget</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.cacheplacement.degree_centrality_cache_placement">
<code class="descname">degree_centrality_cache_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>cache_budget</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/cacheplacement.html#degree_centrality_cache_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.cacheplacement.degree_centrality_cache_placement" title="Permalink to this definition">¶</a></dt>
<dd><p>Places cache budget proportionally to the degree of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>cache_budget</strong> : int</p>
<blockquote class="last">
<div><p>The cumulative cache budget</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.cacheplacement.betweenness_centrality_cache_placement">
<code class="descname">betweenness_centrality_cache_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>cache_budget</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/cacheplacement.html#betweenness_centrality_cache_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.cacheplacement.betweenness_centrality_cache_placement" title="Permalink to this definition">¶</a></dt>
<dd><p>Places cache budget proportionally to the betweenness centrality of the
node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>cache_budget</strong> : int</p>
<blockquote class="last">
<div><p>The cumulative cache budget</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.cacheplacement.uniform_consolidated_cache_placement">
<code class="descname">uniform_consolidated_cache_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>cache_budget</em>, <em>spread=0.5</em>, <em>metric_dict=None</em>, <em>target='top'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/cacheplacement.html#uniform_consolidated_cache_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.cacheplacement.uniform_consolidated_cache_placement" title="Permalink to this definition">¶</a></dt>
<dd><p>Consolidate caches in nodes with top centrality.</p>
<p>Differently from other cache placement strategies that place cache space
to all nodes but proportionally to their centrality, this strategy places
caches of all the same size in a set of selected nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>cache_budget</strong> : int</p>
<blockquote>
<div><p>The cumulative cache budget</p>
</div></blockquote>
<p><strong>spread</strong> : float [0, 1], optional</p>
<blockquote>
<div><p>The spread factor, The greater it is the more the cache budget is
spread among nodes. If it is 1, all candidate nodes are assigned a
cache, if it is 0, only the node with the highest/lowest centrality
is assigned a cache</p>
</div></blockquote>
<p><strong>metric_dict</strong> : dict, optional</p>
<blockquote>
<div><p>The centrality metric according to which nodes are selected. If not
specified, betweenness centrality is selected.</p>
</div></blockquote>
<p><strong>target</strong> : (&#8220;top&#8221; | &#8220;bottom&#8221;), optional</p>
<blockquote class="last">
<div><p>The subsection of the ranked node on which to the deploy caches.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.cacheplacement.random_cache_placement">
<code class="descname">random_cache_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>cache_budget</em>, <em>n_cache_nodes</em>, <em>seed=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/cacheplacement.html#random_cache_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.cacheplacement.random_cache_placement" title="Permalink to this definition">¶</a></dt>
<dd><p>Deploy caching nodes randomly</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>cache_budget</strong> : int</p>
<blockquote>
<div><p>The cumulative cache budget</p>
</div></blockquote>
<p><strong>n_nodes</strong> : int</p>
<blockquote class="last">
<div><p>The number of caching nodes to deploy</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.cacheplacement.optimal_median_cache_placement">
<code class="descname">optimal_median_cache_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>cache_budget</em>, <em>n_cache_nodes</em>, <em>hit_ratio</em>, <em>weight='delay'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/cacheplacement.html#optimal_median_cache_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.cacheplacement.optimal_median_cache_placement" title="Permalink to this definition">¶</a></dt>
<dd><p>Deploy caching nodes in locations that minimize overall latency assuming
a partitioned strategy (a la Google Global Cache). According to this, in
the network, a set of caching nodes are deployed and each receiver is
mapped to one and only one caching node. Requests from this receiver are
always sent to the designated caching node. In case of cache miss requests
are forwarded to the original source.</p>
<p>This placement problem can be mapped to the p-median location-allocation
problem. This function solves this problem using the vertex substitution
heuristic, which practically works like the k-medoid PAM algorithms, which
is also similar to the k-means clustering algorithm. The result is not
guaranteed to be globally optimal, only locally optimal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>cache_budget</strong> : int</p>
<blockquote>
<div><p>The cumulative cache budget</p>
</div></blockquote>
<p><strong>n_nodes</strong> : int</p>
<blockquote>
<div><p>The number of caching nodes to deploy</p>
</div></blockquote>
<p><strong>hit_ratio</strong> : float</p>
<blockquote>
<div><p>The expected cache hit ratio of a single cache</p>
</div></blockquote>
<p><strong>weight</strong> : str</p>
<blockquote class="last">
<div><p>The weight attribute</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This placement assumes that all receivers have degree = 1 and are connected
to an ICR candidate nodes. Also, it assumes that contents are uniformly
assigned to sources.</p>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.cacheplacement.optimal_hashrouting_cache_placement">
<code class="descname">optimal_hashrouting_cache_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>cache_budget</em>, <em>n_cache_nodes</em>, <em>hit_ratio</em>, <em>weight='delay'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/cacheplacement.html#optimal_hashrouting_cache_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.cacheplacement.optimal_hashrouting_cache_placement" title="Permalink to this definition">¶</a></dt>
<dd><p>Deploy caching nodes for hashrouting in optimized location</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>cache_budget</strong> : int</p>
<blockquote>
<div><p>The cumulative cache budget</p>
</div></blockquote>
<p><strong>n_nodes</strong> : int</p>
<blockquote>
<div><p>The number of caching nodes to deploy</p>
</div></blockquote>
<p><strong>hit_ratio</strong> : float</p>
<blockquote>
<div><p>The expected global cache hit ratio</p>
</div></blockquote>
<p><strong>weight</strong> : str, optional</p>
<blockquote class="last">
<div><p>The weight attribute. Default is &#8216;delay&#8217;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.cacheplacement.clustered_hashrouting_cache_placement">
<code class="descname">clustered_hashrouting_cache_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>cache_budget</em>, <em>n_clusters</em>, <em>policy</em>, <em>distance='delay'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/cacheplacement.html#clustered_hashrouting_cache_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.cacheplacement.clustered_hashrouting_cache_placement" title="Permalink to this definition">¶</a></dt>
<dd><p>Deploy caching nodes for hashrouting in with clusters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>cache_budget</strong> : int</p>
<blockquote>
<div><p>The cumulative cache budget</p>
</div></blockquote>
<p><strong>n_clusters</strong> : int</p>
<blockquote>
<div><p>The number of clusters</p>
</div></blockquote>
<p><strong>policy</strong> : str (node_const | cluster_const)</p>
<blockquote>
<div><p>The expected global cache hit ratio</p>
</div></blockquote>
<p><strong>distance</strong> : str</p>
<blockquote class="last">
<div><p>The attribute used to quantify distance between pairs of nodes.
Default is &#8216;delay&#8217;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-icarus.scenarios.contentplacement">
<span id="icarus-scenarios-contentplacement-module"></span><h2>icarus.scenarios.contentplacement module<a class="headerlink" href="#module-icarus.scenarios.contentplacement" title="Permalink to this headline">¶</a></h2>
<p>Content placement strategies.</p>
<p>This module contains function to decide the allocation of content objects to
source nodes.</p>
<dl class="function">
<dt id="icarus.scenarios.contentplacement.uniform_content_placement">
<code class="descname">uniform_content_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>contents</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/contentplacement.html#uniform_content_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.contentplacement.uniform_content_placement" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Places content objects to source nodes randomly following a uniform</dt>
<dd>distribution.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>contents</strong> : iterable</p>
<blockquote>
<div><blockquote>
<div><p>Iterable of content objects</p>
</div></blockquote>
<dl class="docutils">
<dt>source_nodes</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list</span><dd><p class="first last">List of nodes of the topology which are content sources</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cache_placement</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary mapping content objects to source nodes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A deterministic placement of objects (e.g., for reproducing results) can be
achieved by using a fix seed value</p>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.contentplacement.weighted_content_placement">
<code class="descname">weighted_content_placement</code><span class="sig-paren">(</span><em>topology</em>, <em>contents</em>, <em>source_weights</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/contentplacement.html#weighted_content_placement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.contentplacement.weighted_content_placement" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Places content objects to source nodes randomly according to the weight</dt>
<dd>of the source node.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : Topology</p>
<blockquote>
<div><p>The topology object</p>
</div></blockquote>
<p><strong>contents</strong> : iterable</p>
<blockquote>
<div><blockquote>
<div><p>Iterable of content objects</p>
</div></blockquote>
<dl class="docutils">
<dt>source_weights</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd><p class="first last">Dict mapping nodes nodes of the topology which are content sources and
the weight according to which content placement decision is made.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cache_placement</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary mapping content objects to source nodes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A deterministic placement of objects (e.g., for reproducing results) can be
achieved by using a fix seed value</p>
</dd></dl>

</div>
<div class="section" id="module-icarus.scenarios.topology">
<span id="icarus-scenarios-topology-module"></span><h2>icarus.scenarios.topology module<a class="headerlink" href="#module-icarus.scenarios.topology" title="Permalink to this headline">¶</a></h2>
<p>Functions for creating or importing topologies for experiments.</p>
<p>To create a custom topology, create a function returning an instance of the
<cite>IcnTopology</cite> class. An IcnTopology is simply a subclass of a Topology class
provided by FNSS.</p>
<dl class="docutils">
<dt>A valid ICN topology must have the following attributes:</dt>
<dd><ul class="first last simple">
<li>Each node must have one stack among: source, receiver, router</li>
<li>The topology must have an attribute called <cite>icr_candidates</cite> which is a set
of router nodes on which a cache may be possibly deployed. Caches are not
deployed directly at topology creation, instead they are deployed by a
cache placement algorithm.</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="icarus.scenarios.topology.IcnTopology">
<em class="property">class </em><code class="descname">IcnTopology</code><span class="sig-paren">(</span><em>data=None</em>, <em>name=''</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#IcnTopology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.IcnTopology" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">fnss.topologies.topology.Topology</span></code></p>
<p>Class modelling an ICN topology</p>
<p>An ICN topology is a simple FNSS Topology with addition methods that
return sets of caching nodes, sources and receivers.</p>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">name</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_cycle</span></code>(nodes,&nbsp;**attr)</td>
<td>Add a cycle.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_edge</span></code>(u,&nbsp;v[,&nbsp;attr_dict])</td>
<td>Add an edge between u and v.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_edges_from</span></code>(ebunch[,&nbsp;attr_dict])</td>
<td>Add all the edges in ebunch.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_node</span></code>(n[,&nbsp;attr_dict])</td>
<td>Add a single node n and update node attributes.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_nodes_from</span></code>(nodes,&nbsp;**attr)</td>
<td>Add multiple nodes.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_path</span></code>(nodes,&nbsp;**attr)</td>
<td>Add a path.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">add_star</span></code>(nodes,&nbsp;**attr)</td>
<td>Add a star.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">add_weighted_edges_from</span></code>(ebunch[,&nbsp;weight])</td>
<td>Add all the edges in ebunch as weighted edges with specified weights.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">adjacency_iter</span></code>()</td>
<td>Return an iterator of (node, adjacency dict) tuples for all nodes.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">adjacency_list</span></code>()</td>
<td>Return an adjacency list representation of the graph.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">adjlist_dict_factory</span></code></td>
<td>alias of <a class="reference external" href="https://docs.python.org/2/library/stdtypes.html#dict" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">applications</span></code>()</td>
<td>Return a dictionary of all applications deployed, keyed by node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">buffers</span></code>()</td>
<td>Return a dictionary of all buffer sizes, keyed by interface</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#icarus.scenarios.topology.IcnTopology.cache_nodes" title="icarus.scenarios.topology.IcnTopology.cache_nodes"><code class="xref py py-obj docutils literal"><span class="pre">cache_nodes</span></code></a>()</td>
<td>Return a dictionary mapping nodes with a cache and respective cache</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">capacities</span></code>()</td>
<td>Return a dictionary of all link capacities, keyed by link</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">clear</span></code>()</td>
<td>Remove all nodes and edges from the graph.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">copy</span></code>()</td>
<td>Return a copy of the topology.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">degree</span></code>([nbunch,&nbsp;weight])</td>
<td>Return the degree of a node or nodes.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">degree_iter</span></code>([nbunch,&nbsp;weight])</td>
<td>Return an iterator for (node, degree).</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">delays</span></code>()</td>
<td>Return a dictionary of all link delays, keyed by link</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">edge_attr_dict_factory</span></code></td>
<td>alias of <a class="reference external" href="https://docs.python.org/2/library/stdtypes.html#dict" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">edges</span></code>([nbunch,&nbsp;data,&nbsp;default])</td>
<td>Return a list of edges.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">edges_iter</span></code>([nbunch,&nbsp;data,&nbsp;default])</td>
<td>Return an iterator over the edges.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">get_edge_data</span></code>(u,&nbsp;v[,&nbsp;default])</td>
<td>Return the attribute dictionary associated with edge (u,v).</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">has_edge</span></code>(u,&nbsp;v)</td>
<td>Return True if the edge (u,v) is in the graph.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">has_node</span></code>(n)</td>
<td>Return True if the graph contains the node n.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">is_directed</span></code>()</td>
<td>Return True if graph is directed, False otherwise.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">is_multigraph</span></code>()</td>
<td>Return True if graph is a multigraph, False otherwise.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">nbunch_iter</span></code>([nbunch])</td>
<td>Return an iterator of nodes contained in nbunch that are also in the graph.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">neighbors</span></code>(n)</td>
<td>Return a list of the nodes connected to the node n.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">neighbors_iter</span></code>(n)</td>
<td>Return an iterator over all neighbors of node n.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">node_dict_factory</span></code></td>
<td>alias of <a class="reference external" href="https://docs.python.org/2/library/stdtypes.html#dict" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">nodes</span></code>([data])</td>
<td>Return a list of the nodes in the graph.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">nodes_iter</span></code>([data])</td>
<td>Return an iterator over the nodes.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">nodes_with_selfloops</span></code>()</td>
<td>Return a list of nodes with self loops.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">number_of_edges</span></code>([u,&nbsp;v])</td>
<td>Return the number of edges between two nodes.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">number_of_nodes</span></code>()</td>
<td>Return the number of nodes in the graph.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">number_of_selfloops</span></code>()</td>
<td>Return the number of selfloop edges.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">order</span></code>()</td>
<td>Return the number of nodes in the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#icarus.scenarios.topology.IcnTopology.receivers" title="icarus.scenarios.topology.IcnTopology.receivers"><code class="xref py py-obj docutils literal"><span class="pre">receivers</span></code></a>()</td>
<td>Return a set of receiver nodes</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_edge</span></code>(u,&nbsp;v)</td>
<td>Remove the edge between u and v.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_edges_from</span></code>(ebunch)</td>
<td>Remove all edges specified in ebunch.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_node</span></code>(n)</td>
<td>Remove node n.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">remove_nodes_from</span></code>(nodes)</td>
<td>Remove multiple nodes.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">selfloop_edges</span></code>([data,&nbsp;default])</td>
<td>Return a list of selfloop edges.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">size</span></code>([weight])</td>
<td>Return the number of edges.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#icarus.scenarios.topology.IcnTopology.sources" title="icarus.scenarios.topology.IcnTopology.sources"><code class="xref py py-obj docutils literal"><span class="pre">sources</span></code></a>()</td>
<td>Return a set of source nodes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">stacks</span></code>()</td>
<td>Return a dictionary of all node stacks, keyed by node</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">subgraph</span></code>(nbunch)</td>
<td>Return the subgraph induced on nodes in nbunch.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">to_directed</span></code>()</td>
<td>Return a directed representation of the topology.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">to_undirected</span></code>()</td>
<td>Return an undirected copy of the topology.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">weights</span></code>()</td>
<td>Return a dictionary of all link weights, keyed by link</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="icarus.scenarios.topology.IcnTopology.cache_nodes">
<code class="descname">cache_nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#IcnTopology.cache_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.IcnTopology.cache_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary mapping nodes with a cache and respective cache
size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cache_nodes</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary mapping node identifiers and cache size</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="icarus.scenarios.topology.IcnTopology.receivers">
<code class="descname">receivers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#IcnTopology.receivers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.IcnTopology.receivers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of receiver nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>receivers</strong> : set</p>
<blockquote class="last">
<div><p>Set of receiver nodes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="icarus.scenarios.topology.IcnTopology.sources">
<code class="descname">sources</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#IcnTopology.sources"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.IcnTopology.sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of source nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sources</strong> : set</p>
<blockquote class="last">
<div><p>Set of source nodes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.topology.topology_tree">
<code class="descname">topology_tree</code><span class="sig-paren">(</span><em>k</em>, <em>h</em>, <em>delay=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#topology_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.topology_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tree topology, with a source at the root, receivers at the
leafs and caches at all intermediate nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h</strong> : int</p>
<blockquote>
<div><p>The height of the tree</p>
</div></blockquote>
<p><strong>k</strong> : int</p>
<blockquote>
<div><p>The branching factor of the tree</p>
</div></blockquote>
<p><strong>delay</strong> : float</p>
<blockquote>
<div><p>The link delay in milliseconds</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topology</strong> : IcnTopology</p>
<blockquote class="last">
<div><p>The topology object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.topology.topology_path">
<code class="descname">topology_path</code><span class="sig-paren">(</span><em>n</em>, <em>delay=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#topology_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.topology_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a path topology with a receiver on node <cite>0</cite> and a source at node
&#8216;n-1&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : int (&gt;=3)</p>
<blockquote>
<div><p>The number of nodes</p>
</div></blockquote>
<p><strong>delay</strong> : float</p>
<blockquote>
<div><p>The link delay in milliseconds</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topology</strong> : IcnTopology</p>
<blockquote class="last">
<div><p>The topology object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.topology.topology_ring">
<code class="descname">topology_ring</code><span class="sig-paren">(</span><em>n</em>, <em>delay_int=1</em>, <em>delay_ext=5</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#topology_ring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.topology_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ring topology</p>
<p>This topology is comprised of a ring of <em>n</em> nodes. Each of these nodes is
attached to a receiver. In addition one router is attached to a source.
Therefore, this topology has in fact 2n + 1 nodes.</p>
<p>It models the case of a metro ring network, with many receivers and one
only source towards the core network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : int</p>
<blockquote>
<div><p>The number of routers in the ring</p>
</div></blockquote>
<p><strong>delay_int</strong> : float</p>
<blockquote>
<div><p>The internal link delay in milliseconds</p>
</div></blockquote>
<p><strong>delay_ext</strong> : float</p>
<blockquote>
<div><p>The external link delay in milliseconds</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topology</strong> : IcnTopology</p>
<blockquote class="last">
<div><p>The topology object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.topology.topology_mesh">
<code class="descname">topology_mesh</code><span class="sig-paren">(</span><em>n</em>, <em>m</em>, <em>delay_int=1</em>, <em>delay_ext=5</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#topology_mesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.topology_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ring topology</p>
<p>This topology is comprised of a mesh of <em>n</em> nodes. Each of these nodes is
attached to a receiver. In addition <em>m</em> router are attached each to a source.
Therefore, this topology has in fact 2n + m nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : int</p>
<blockquote>
<div><p>The number of routers in the ring</p>
</div></blockquote>
<p><strong>m</strong> : int</p>
<blockquote>
<div><p>The number of sources</p>
</div></blockquote>
<p><strong>delay_int</strong> : float</p>
<blockquote>
<div><p>The internal link delay in milliseconds</p>
</div></blockquote>
<p><strong>delay_ext</strong> : float</p>
<blockquote>
<div><p>The external link delay in milliseconds</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topology</strong> : IcnTopology</p>
<blockquote class="last">
<div><p>The topology object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.topology.topology_geant">
<code class="descname">topology_geant</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#topology_geant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.topology_geant" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scenario based on GEANT topology</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seed</strong> : int, optional</p>
<blockquote>
<div><p>The seed used for random number generation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topology</strong> : fnss.Topology</p>
<blockquote class="last">
<div><p>The topology object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.topology.topology_tiscali">
<code class="descname">topology_tiscali</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#topology_tiscali"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.topology_tiscali" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scenario based on Tiscali topology, parsed from RocketFuel dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seed</strong> : int, optional</p>
<blockquote>
<div><p>The seed used for random number generation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topology</strong> : fnss.Topology</p>
<blockquote class="last">
<div><p>The topology object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.topology.topology_wide">
<code class="descname">topology_wide</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#topology_wide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.topology_wide" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scenario based on GARR topology</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seed</strong> : int, optional</p>
<blockquote>
<div><p>The seed used for random number generation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topology</strong> : fnss.Topology</p>
<blockquote class="last">
<div><p>The topology object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.topology.topology_garr">
<code class="descname">topology_garr</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#topology_garr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.topology_garr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scenario based on GARR topology</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seed</strong> : int, optional</p>
<blockquote>
<div><p>The seed used for random number generation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topology</strong> : fnss.Topology</p>
<blockquote class="last">
<div><p>The topology object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="icarus.scenarios.topology.topology_rocketfuel_latency">
<code class="descname">topology_rocketfuel_latency</code><span class="sig-paren">(</span><em>asn</em>, <em>source_ratio=0.1</em>, <em>ext_delay=34</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/topology.html#topology_rocketfuel_latency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.topology.topology_rocketfuel_latency" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a generic RocketFuel topology with annotated latencies</p>
<p>To each node of the parsed topology it is attached an artificial receiver
node. To the routers with highest degree it is also attached a source node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>asn</strong> : int</p>
<blockquote>
<div><p>AS number</p>
</div></blockquote>
<p><strong>source_ratio</strong> : float</p>
<blockquote>
<div><p>Ratio between number of source nodes (artificially attached) and routers</p>
</div></blockquote>
<p><strong>ext_delay</strong> : float</p>
<blockquote class="last">
<div><p>Delay on external nodes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-icarus.scenarios.workload">
<span id="icarus-scenarios-workload-module"></span><h2>icarus.scenarios.workload module<a class="headerlink" href="#module-icarus.scenarios.workload" title="Permalink to this headline">¶</a></h2>
<p>Traffic workloads</p>
<p>Every traffic workload to be used with Icarus must be modelled as an iterable
class, i.e. a class with at least an <cite>__init__</cite> method (through which it is
initialized, with values taken from the configuration file) and an <cite>__iter__</cite>
method that is called to return a new event.</p>
<p>Each call to the <cite>__iter__</cite> method must return a 2-tuple in which the first
element is the timestamp at which the event occurs and the second is a
dictionary, describing the event, which must contain at least the three
following attributes:</p>
<blockquote>
<div><ul class="simple">
<li>receiver: The name of the node issuing the request</li>
<li>content: The name of the content for which the request is issued</li>
<li>log: A boolean value indicating whether this request should be logged or not
for measurement purposes.</li>
</ul>
</div></blockquote>
<p>Each workload must expose the <cite>contents</cite> attribute which is an iterable of
all content identifiers. This is needed for content placement.</p>
<dl class="class">
<dt id="icarus.scenarios.workload.StationaryWorkload">
<em class="property">class </em><code class="descname">StationaryWorkload</code><span class="sig-paren">(</span><em>topology</em>, <em>n_contents</em>, <em>alpha</em>, <em>beta=0</em>, <em>rate=1.0</em>, <em>n_warmup=100000</em>, <em>n_measured=400000</em>, <em>seed=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/workload.html#StationaryWorkload"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.workload.StationaryWorkload" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>This function generates events on the fly, i.e. instead of creating an
event schedule to be kept in memory, returns an iterator that generates
events when needed.</p>
<p>This is useful for running large schedules of events where RAM is limited
as its memory impact is considerably lower.</p>
<p>These requests are Poisson-distributed while content popularity is
Zipf-distributed</p>
<p>All requests are mapped to receivers uniformly unless a positive <em>beta</em>
parameter is specified.</p>
<p>If a <em>beta</em> parameter is specified, then receivers issue requests at
different rates. The algorithm used to determine the requests rates for
each receiver is the following:</p>
<blockquote>
<div><ul class="simple">
<li>All receiver are sorted in decreasing order of degree of the PoP they
are attached to. This assumes that all receivers have degree = 1 and are
attached to a node with degree &gt; 1</li>
<li>Rates are then assigned following a Zipf distribution of coefficient
beta where nodes with higher-degree PoPs have a higher request rate</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : fnss.Topology</p>
<blockquote>
<div><p>The topology to which the workload refers</p>
</div></blockquote>
<p><strong>n_contents</strong> : int</p>
<blockquote>
<div><p>The number of content object</p>
</div></blockquote>
<p><strong>alpha</strong> : float</p>
<blockquote>
<div><p>The Zipf alpha parameter</p>
</div></blockquote>
<p><strong>beta</strong> : float, optional</p>
<blockquote>
<div><p>Parameter indicating</p>
</div></blockquote>
<p><strong>rate</strong> : float, optional</p>
<blockquote>
<div><p>The mean rate of requests per second</p>
</div></blockquote>
<p><strong>n_warmup</strong> : int, optional</p>
<blockquote>
<div><p>The number of warmup requests (i.e. requests executed to fill cache but
not logged)</p>
</div></blockquote>
<p><strong>n_measured</strong> : int, optional</p>
<blockquote>
<div><p>The number of logged requests after the warmup</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>events</strong> : iterator</p>
<blockquote class="last">
<div><p>Iterator of events. Each event is a 2-tuple where the first element is
the timestamp at which the event occurs and the second element is a
dictionary of event attributes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="icarus.scenarios.workload.StationaryWorkload.name">
<code class="descname">name</code><em class="property"> = 'STATIONARY'</em><a class="headerlink" href="#icarus.scenarios.workload.StationaryWorkload.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="icarus.scenarios.workload.GlobetraffWorkload">
<em class="property">class </em><code class="descname">GlobetraffWorkload</code><span class="sig-paren">(</span><em>topology</em>, <em>reqs_file</em>, <em>contents_file</em>, <em>beta=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/workload.html#GlobetraffWorkload"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.workload.GlobetraffWorkload" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Parse requests from GlobeTraff workload generator</p>
<p>All requests are mapped to receivers uniformly unless a positive <em>beta</em>
parameter is specified.</p>
<p>If a <em>beta</em> parameter is specified, then receivers issue requests at
different rates. The algorithm used to determine the requests rates for
each receiver is the following:</p>
<blockquote>
<div><ul class="simple">
<li>All receiver are sorted in decreasing order of degree of the PoP they
are attached to. This assumes that all receivers have degree = 1 and are
attached to a node with degree &gt; 1</li>
<li>Rates are then assigned following a Zipf distribution of coefficient
beta where nodes with higher-degree PoPs have a higher request rate</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : fnss.Topology</p>
<blockquote>
<div><p>The topology to which the workload refers</p>
</div></blockquote>
<p><strong>reqs_file</strong> : str</p>
<blockquote>
<div><p>The GlobeTraff request file</p>
</div></blockquote>
<p><strong>contents_file</strong> : str</p>
<blockquote>
<div><p>The GlobeTraff content file</p>
</div></blockquote>
<p><strong>beta</strong> : float, optional</p>
<blockquote>
<div><p>Spatial skewness of requests rates</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>events</strong> : iterator</p>
<blockquote class="last">
<div><p>Iterator of events. Each event is a 2-tuple where the first element is
the timestamp at which the event occurs and the second element is a
dictionary of event attributes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="icarus.scenarios.workload.GlobetraffWorkload.name">
<code class="descname">name</code><em class="property"> = 'GLOBETRAFF'</em><a class="headerlink" href="#icarus.scenarios.workload.GlobetraffWorkload.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="icarus.scenarios.workload.TraceDrivenWorkload">
<em class="property">class </em><code class="descname">TraceDrivenWorkload</code><span class="sig-paren">(</span><em>topology</em>, <em>reqs_file</em>, <em>contents_file</em>, <em>n_contents</em>, <em>n_warmup</em>, <em>n_measured</em>, <em>rate=1.0</em>, <em>beta=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/workload.html#TraceDrivenWorkload"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.workload.TraceDrivenWorkload" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Parse requests from a generic request trace.</p>
<dl class="docutils">
<dt>This workload requires two text files:</dt>
<dd><ul class="first last simple">
<li>a requests file, where each line corresponds to a string identifying
the content requested</li>
<li>a contents file, which lists all unique content identifiers appearing
in the requests file.</li>
</ul>
</dd>
</dl>
<p>Since the trace do not provide timestamps, requests are scheduled according
to a Poisson process of rate <em>rate</em>. All requests are mapped to receivers
uniformly unless a positive <em>beta</em> parameter is specified.</p>
<p>If a <em>beta</em> parameter is specified, then receivers issue requests at
different rates. The algorithm used to determine the requests rates for
each receiver is the following:</p>
<blockquote>
<div><ul class="simple">
<li>All receiver are sorted in decreasing order of degree of the PoP they
are attached to. This assumes that all receivers have degree = 1 and are
attached to a node with degree &gt; 1</li>
<li>Rates are then assigned following a Zipf distribution of coefficient
beta where nodes with higher-degree PoPs have a higher request rate</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topology</strong> : fnss.Topology</p>
<blockquote>
<div><p>The topology to which the workload refers</p>
</div></blockquote>
<p><strong>reqs_file</strong> : str</p>
<blockquote>
<div><p>The path to the requests file</p>
</div></blockquote>
<p><strong>contents_file</strong> : str</p>
<blockquote>
<div><p>The path to the contents file</p>
</div></blockquote>
<p><strong>n_contents</strong> : int</p>
<blockquote>
<div><p>The number of content object (i.e. the number of lines of contents_file)</p>
</div></blockquote>
<p><strong>n_warmup</strong> : int</p>
<blockquote>
<div><p>The number of warmup requests (i.e. requests executed to fill cache but
not logged)</p>
</div></blockquote>
<p><strong>n_measured</strong> : int</p>
<blockquote>
<div><p>The number of logged requests after the warmup</p>
</div></blockquote>
<p><strong>rate</strong> : float, optional</p>
<blockquote>
<div><p>The network-wide mean rate of requests per second</p>
</div></blockquote>
<p><strong>beta</strong> : float, optional</p>
<blockquote>
<div><p>Spatial skewness of requests rates</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>events</strong> : iterator</p>
<blockquote class="last">
<div><p>Iterator of events. Each event is a 2-tuple where the first element is
the timestamp at which the event occurs and the second element is a
dictionary of event attributes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="icarus.scenarios.workload.TraceDrivenWorkload.name">
<code class="descname">name</code><em class="property"> = 'TRACE_DRIVEN'</em><a class="headerlink" href="#icarus.scenarios.workload.TraceDrivenWorkload.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="icarus.scenarios.workload.YCSBWorkload">
<em class="property">class </em><code class="descname">YCSBWorkload</code><span class="sig-paren">(</span><em>workload</em>, <em>n_contents</em>, <em>n_warmup</em>, <em>n_measured</em>, <em>alpha=0.99</em>, <em>seed=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/icarus/scenarios/workload.html#YCSBWorkload"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#icarus.scenarios.workload.YCSBWorkload" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Yahoo! Cloud Serving Benchmark (YCSB)</p>
<p>The YCSB is a set of reference workloads used to benchmark databases and,
more generally any storage/caching systems. It comprises five workloads:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="40%" />
<col width="30%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Workload</td>
<td>Operations</td>
<td>Record selection</td>
</tr>
<tr class="row-even"><td>A - Update heavy
B - Read heavy
C - Read only
D - Read latest
E - Short ranges</td>
<td>Read: 50%, Update: 50%
Read: 95%, Update: 5%
Read: 100%
Read: 95%, Insert: 5%
Scan: 95%, Insert 5%</td>
<td>Zipfian
Zipfian
Zipfian
Latest
Zipfian/Uniform</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>At the moment only workloads A, B and C are implemented, since they are the
most relevant for caching systems.</p>
<dl class="attribute">
<dt id="icarus.scenarios.workload.YCSBWorkload.name">
<code class="descname">name</code><em class="property"> = 'YCSB'</em><a class="headerlink" href="#icarus.scenarios.workload.YCSBWorkload.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-icarus.scenarios">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-icarus.scenarios" title="Permalink to this headline">¶</a></h2>
<p>This package contains the code for generating simulation scenarios.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Icarus 0.6.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="icarus.html" >icarus package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Lorenzo Saino, Ioannis Psaras.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.5.
    </div>
  </body>
</html>